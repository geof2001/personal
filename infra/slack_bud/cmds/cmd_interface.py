"""
Abstract base class and interface for all SlackCmd classes.

All SlackCmd classes inherit from this class and need to
implement the abstract methods. Some of the abstract methods
will be auto-generated by a script which creates template code
for the command writer to complete.

The common code for authentication and input parsing will be
handled in this class.
"""
from __future__ import print_function

import os
import json
import time
import boto3
from abc import ABCMeta, abstractmethod
import util.bud_helper_util as bud_helper_util
import util.slack_ui_util as slack_ui_util
from util.slack_ui_util import ShowSlackError
from util.bud_helper_util import squash_token_print
from util.bud_helper_util import get_slack_bud_environment
from util.aws_util import get_ssm_parameter

DYNAMODB = boto3.resource('dynamodb')
BUD_USERS_TABLE = DYNAMODB.Table('SlackBudUsers')
SLACK_SESSION_TABLE = DYNAMODB.Table('SlackBudSession')
if 'slackToken' in os.environ['slackToken']:
    EXPECTED_TOKEN = os.environ['slackToken']
else:
    EXPECTED_TOKEN = 'none'

class CmdInterface:
    __metaclass__ = ABCMeta

    def __init__(self, cmd_inputs):
        self._cmd_inputs = cmd_inputs

    @abstractmethod
    def run_command(self): pass

    @abstractmethod
    def get_cmd_properties(self): pass

    @abstractmethod
    def build_cmd_specific_data(self): pass

    @abstractmethod
    def invoke_confirm_command(self): pass

    def get_cmd_input(self):
        """
        A convenience method to
        get the "cmd_input" for this instance.
        :return:
        """
        return self._cmd_inputs

    # NOTE: We might depreciate this by moving to cmd_input.
    # ToDo: Decide if this belongs with cmd_inputs exclusively.
    def get_response_url(self):
        """
        Get the Slack Response URL for long running (more than 3 seconds) tasks.
        :return: str like:
        """
        return self._cmd_inputs.get_response_url()

    def get_help_title(self):
        """
        Called by the global help command to get the help_title from
        the commands properties.
        :return:
        """
        cmd_props = self.get_cmd_properties()
        help_title = cmd_props['help_title']+'\n'
        return help_title

    def show_command_help(self):
        """
        Builds the help screen for this command.

        It needs to read the title, and help example for the command.
        The it needs to do the same for each of the sub-commands.
        :return:
        """
        cmd_props = self.get_cmd_properties()

        text = '*{}*\n'.format(cmd_props['help_title'])

        # File all the sub-commands for this command.
        sub_cmd_list = cmd_props['sub_commands']
        for curr_sub_cmd in sub_cmd_list:
            prop_key = 'props_{}'.format(curr_sub_cmd)
            sub_cmd_props = cmd_props[prop_key]
            help_text = sub_cmd_props['help_text']
            text += '\n--\n'
            text += '  {}\n'.format(help_text)
            help_example_list = sub_cmd_props.get('help_examples')
            if help_example_list:
                for curr_example in help_example_list:
                    text += '    _{}_\n'.format(curr_example)
            # Print out switch, details.
            is_first = True
            for curr_key in sub_cmd_props.keys():
                if is_first:
                    is_first = False
                    text += '      *switches*\n'
                if curr_key.startswith('switch-'):
                    if curr_key == 'switch-templates':
                        template_props = sub_cmd_props[curr_key]
                        for curr_switch in template_props:
                            parts = curr_switch.split('-')
                            type = '(required)'
                            if len(parts) == 2:
                                type = '({})'.format(parts[1])
                            text += '    `{}` {}'.format(parts[0], type)
                        continue
                    else:
                        curr_switch_props = sub_cmd_props[curr_key]
                        aliases_list = curr_switch_props.get('aliases')
                        is_required = curr_switch_props.get('required')
                        is_required_text = ''
                        if is_required:
                            is_required_text = '(Required)'
                        help_text = curr_switch_props.get('help_text')
                        switch_name = curr_key.split('-')[1]
                        text += '      `-{}`: {} {} {}\n'\
                            .format(switch_name, help_text, aliases_list, is_required_text)

        # return slack_ui_util.ephemeral_text_response(text)
        return self.slack_ui_standard_response(None, text, color='#ffaa60')

    def authenticate_request(self, params):
        """
        Verify this is a valid request, but looking at the
        slack token when possible and verify the user making
        the request as the proper permissions.

        If invalid throw record all the relevant data in the
        log and then throw a SlackUIError with a message for the
        user.

        If valid just continue.
        :return: None
        """
        try:
            print('Authenticating Request')
            # If this is a confirmation command we might have different data.
            if self._cmd_inputs.is_confirmation_cmd():
                # print('AuthReq ConfirmCmd: params={}'.format(params))
                squash_token_print("AuthReq ConfirmCmd: params=", params)
                # Do we have slack token, or user information?
            else:
                # Get SlackToken and user information.
                # print('AuthReq StdCmd: params={}'.format(params))
                squash_token_print("AuthReq StdCmd: params=", params)
                # Verify token
                if not is_valid_token(params):
                    # print('FAILED: AUTH CHECK. Invalid slackToken! params={}'.format(params))
                    squash_token_print("FAILED: AUTH CHECK. Invalid slackToken! params=", params)
                    text = "Invalid token. This request has been logged."
                    raise ShowSlackError(text)
                    # return slack_ui_util.ephemeral_text_response(text)
                else:
                    print('Passed slackToken check')
                # Verify user and check role
                slack_user = look_up_bud_user(params)
                if slack_user is None:
                    # print('FAILED: AUTH CHECK. Invalid user. params={}'.format(params))
                    squash_token_print("FAILED: AUTH CHECK. Invalid user. params=", params)
                    text = "Invalid user. Ask an admin to add user to this this service."
                    raise ShowSlackError(text)
                    # return slack_ui_util.ephemeral_text_response(text)
                else:
                    # if we have a valid user, compare their role to the cmd permission_level
                    slack_user_name = slack_user['username']
                    slack_user_role = slack_user['role']
                    print('Found Slack user: {}'.format(slack_user_name))
                    print('User role: {}'.format(slack_user_role))
                    cmd_props = self.get_cmd_properties()
                    cmd_permission_level = cmd_props['permission_level']
                    print('Command permission level: {}'.format(cmd_permission_level))
                    if cmd_permission_level == 'admin' and slack_user_role == 'admin':
                        print('User role matches cmd permission level.')
                    elif cmd_permission_level is 'dev':
                        print('Command is dev role, user authorized')
                    else:
                        print('User not authorized to run command.')
                        text = "Admin role required to run command."
                        raise ShowSlackError(text)
            print('PASSED: AUTH CHECK.')
            return None

        except Exception as ex:
            bud_helper_util.log_traceback_exception(ex)
            raise ShowSlackError("Failed authentication! See log for details.")

    def parse_inputs(self):
        """
        This is the method that reads the properties of the command class.
        It then validates that the request is valid according to the properties,
        and generate the input map according to this properties.

        If something is invalid about the command it raises and ShowSlackError,
        otherwise it update the cmd_inputs and continues returning None.
        :return: None if valid otherwise raise an error.
        """
        try:
            cmd_inputs = self.get_cmd_input()
            print('ParseInputs: cmd_inputs={}'.format(cmd_inputs))
            if cmd_inputs.is_confirmation_cmd():
                # We don't parse confirmation responses.
                print("This is a confirmation response. Don't parse by props rules.")
                return

            cmd_props = self.get_cmd_properties()
            print('ParseInputs: cmd_props={}'.format(cmd_props))

            # Does this command have the '--show' property, to make responses public?
            self.check_for_is_public_property()

            # Does this command have a sub-command? If so, it needs to be lower case.
            sub_cmd_list = cmd_props['sub_commands']
            if len(sub_cmd_list) == 0:
                # Commands without sub-command don't take arguments. just return from here.
                return None

            # Handle case of mixed sub-commands and one default command.
            if '_default_' in sub_cmd_list:
                check_for_dash = self._cmd_inputs.get_by_index(1)
                if check_for_dash.startswith('-'):
                    self._cmd_inputs.set_default_sub_command()
                elif len(sub_cmd_list) == 1:
                    self._cmd_inputs.set_default_sub_command()

            # Set sub command and then verify it is in the list.
            sub_cmd = self._cmd_inputs.get_by_index(1)
            self._cmd_inputs._sub_cmd = sub_cmd.lower()

            curr_sub_cmd = self._cmd_inputs.get_sub_command()
            # help command is special
            if curr_sub_cmd == 'help':
                return

            if curr_sub_cmd not in sub_cmd_list:
                raise ShowSlackError("Didn't find '{}' in list of sub-commands.".format(curr_sub_cmd))

            # The sub_cmd is verified now parse it's parameters.
            prop_key = 'props_{}'.format(curr_sub_cmd)
            print('SubCmd Property key: "{}"'.format(prop_key))
            sub_cmd_props = cmd_props[prop_key]
            if not sub_cmd_props:
                cmd_class_name = self.__class__.__name__
                raise ValueError("Missing property '{}', for cmd class: {}".format(prop_key, cmd_class_name))

            # The list is valid now parse the command line and make the key/value dictionary.
            self.create_args_key_value_map()
            self.apply_rules_to_key_value_map(sub_cmd_props)
            self._cmd_inputs.log_state('AfterRules:')  # temporary

        except ShowSlackError:
            raise
        except Exception as ex:
            bud_helper_util.log_traceback_exception(ex)
            raise ShowSlackError("Invalid request. See log for details.")

    def slack_ui_standard_response(self, title, text, color='#a0ffaa'):
        """
        Framework standard response, which gets the ephemeral setting,
        response url, and lambda funtion from the class.
        :param title:
        :param text:
        :param color:
        :return:
        """
        cmd_inputs = self.get_cmd_input()
        where_am_i = cmd_inputs.get_where_am_i()
        print('slack_ui_standard_response: {} is at {}'.format(title, where_am_i))

        is_public_response = cmd_inputs.is_public_response()

        if where_am_i == 'shorttask':
            return slack_ui_util.text_command_response(title, text, color=color, is_public=is_public_response)
        elif where_am_i == 'longtask':
            response_url = cmd_inputs.get_response_url()
            return slack_ui_util.text_command_response(
                title, text, color=color, post=True, response_url=response_url, is_public=is_public_response)

    def get_fallback_string_from_payload(self, params):
        """
        Returns a string put in by command to verify it is confirmation response.
        :param params:
        :return: str like: CmdDeploy
        """
        if 'payload' in params:
            return json.loads(params['payload'][0])['original_message']['attachments'][0]['fallback']

    def set_fallback_value(self):
        """
        Is this method to define the fallback string used by the slack confirm process.

        :param self:
        :return: String which it fallback value for this class
        """
        return self.__class__.__name__

    def is_confirm_command(self, params):
        """
        Return help text for your command in slack format here.
        """
        try:
            fallback_str = self.get_fallback_string_from_payload(params)
            if fallback_str is None:
                return False
            elif fallback_str == self.__class__.__name__:
                return True
            return False

        except ShowSlackError as slack_error_message:
            print(type(slack_error_message))
            print(slack_error_message.args)
            print(slack_error_message)

            return False

    def create_longtask_payload(self, custom_data=None):
        """
        Use this method to package data before passing to the long
        :param self:
        :param custom_data:
        :return: Python dictionary?
        """
        cmd_inputs = self.get_cmd_input()
        if custom_data:
            payload = {
                'task': self.set_fallback_value(),
                'params': cmd_inputs.serialize(),
                'custom_data': custom_data
            }
        else:
            payload = {
                'task': self.set_fallback_value(),
                'params': cmd_inputs.serialize()
            }
        return payload

    def create_args_key_value_map(self):
        """
        Create the key/value map, from the command line.
        :return: None, just change state internally.
        """
        try:
            arg_index = 0
            just_params_list = []
            for curr_arg in self._cmd_inputs._arg_list:
                arg_index += 1
                if arg_index > 2:
                    just_params_list.append(curr_arg)

            # Walk the command looking for key value pairs.
            # -e dev -r us-east-1 -s content --show
            next_index = 0
            kv_map = {}
            for curr_arg in just_params_list:
                next_index += 1
                if curr_arg.startswith('-'):
                    key = curr_arg.replace('-', '')
                    # Get the next element if found.
                    value = just_params_list[next_index]\
                        if next_index < len(just_params_list)\
                        else None
                    if not value:
                        kv_map[key] = True
                        print('Setting property: {} true'.format(key))
                    elif value.startswith('-'):
                        kv_map[key] = True
                        print('Setting property: {} true'.format(key))
                    else:
                        kv_map[key] = value
                        print('Setting: {}={}'.format(key, value))
            self._cmd_inputs.set_key_value_map(kv_map)
            return None

        except ShowSlackError:
            raise
        except Exception as ex:
            bud_helper_util.log_traceback_exception(ex)
            raise ShowSlackError('Error creating input map. See logs.')

    def apply_rules_to_key_value_map(self, sub_cmd_props):
        """
        Apply the rules of from the sub_cmd's property dictionary to the map that already
        exists.
        :param sub_cmd_props:
        :return: None, state in modified internally.
        """
        # Apply standard rules
        templates = sub_cmd_props.get('switch-templates')
        if 'env' in templates:
            self.apply_env_rules()
        if 'env-optional' in templates:
            self.apply_env_rules(optional=True)
        if 'region' in templates:
            self.apply_region_rules()
        if 'region-optional' in templates:
            self.apply_region_rules(optional=True)
        if 'region-default' in templates:
            self.apply_region_rules(default='us-east-1')
        if 'service' in templates:
            self.apply_service_rules()
        if 'service-optional' in templates:
            self.apply_service_rules(optional=True)

        # Find all the custom rules for this sub-command
        all_keys_list = sub_cmd_props.keys()
        switch_keys = [i for i in all_keys_list if i.startswith('switch-')]
        switch_keys = [v for v in switch_keys if v != 'switch-templates']
        for curr_switch_rule_key in switch_keys:
            print('looking for rule: {}'.format(curr_switch_rule_key))
            curr_rule = sub_cmd_props.get(curr_switch_rule_key)
            self.apply_custom_rules(curr_rule)

        return None

    def apply_custom_rules(self, rules_dict):
        """
        Apply a custom rule to the args_dict.

        If a required switch is missing raise a ShowSlackError.
        Return none if rules applies successfully.
        :param rules_dict: dictionary with rules for a custom switch
        :return: None since state changes internally.
        """
        try:
            # What are aliases?
            alias_list = rules_dict.get('aliases')
            value = None
            if alias_list:
                for curr_alias in alias_list:
                    value = self._cmd_inputs.get_by_key(curr_alias)
                    if value:
                        print('Found: {} = {}'.format(curr_alias, value))
                        break

            # Is it required?
            is_required = rules_dict.get('required')
            if is_required:
                if not value:
                    err_msg = 'Missing required switch: {}'.format(alias_list)
                    print('Input parse failed custom rule: {}'.format(err_msg))
                    raise ShowSlackError(err_msg)

            if not value:
                # No value for optional switch, stop here.
                return None

            # Verify the type is right. string, int or property.
            param_type = rules_dict.get('type')
            if param_type == 'property':
                # Value needs to by type boolean
                if not isinstance(value, bool):
                    err_msg = 'Param "{}" should be boolean, but value was: {}'.format(curr_alias, value)
                    print('{}'.format(err_msg))
                    raise ShowSlackError(err_msg)
            elif param_type == 'int':
                # Value needs to be integer.
                try:
                    int(value)
                except ValueError:
                    err_msg = 'Param "{}" should be int, but value was: {}'.format(curr_alias, value)
                    print('{}'.format(err_msg))
                    raise ShowSlackError(err_msg)
            elif param_type == 'string':
                print('{} is {}'.format(curr_alias, value))
            else:
                raise ValueError('Invalid "type" property setting: {}'.format(param_type))

            # Should it be lower-case?
            is_lower_case = False
            lc_value = rules_dict.get('lower_case')
            if lc_value:
                is_lower_case = lc_value

            if is_lower_case and param_type == 'string':
                value = value.lower()

            # populate all aliases
            for curr_alias in alias_list:
                self._cmd_inputs.set_cmd_inputs_value(curr_alias, value)

            return None

        except ShowSlackError:
            raise
        except Exception as ex:
            bud_helper_util.log_traceback_exception(ex)
            raise ShowSlackError('Error parsing inputs. Check logs.')

    def apply_env_rules(self, optional=False):
        """
        Apply rules for the (-e) env switch
        :return:
        """
        value = self._cmd_inputs.get_by_key('e')
        if not value:
            value = self._cmd_inputs.get_by_key('env')
        if not value:
            if not optional:
                raise ShowSlackError('Missing param. Requires -e (env) switch')
            else:
                return None

        value = value.lower()
        # check valid values
        expect_list = ['dev', 'qa', 'prod']
        if value not in expect_list:
            raise ShowSlackError('Invalid value for -e (env) switch.'
                                 ' Expect: {}. Was: "{}"'.format(expect_list, value))

        # propagate the lower case value to aliases.
        self._cmd_inputs.set_cmd_inputs_value('e', value)
        self._cmd_inputs.set_cmd_inputs_value('env', value)

    def apply_region_rules(self, optional=False, default=None):
        """
        Apply rules for the (-r) region switch
        :return: None
        """
        value = self._cmd_inputs.get_by_key('r')
        if not value:
            value = self._cmd_inputs.get_by_key('region')
        # set default value if that is an option.
        if not value:
            if default:
                value = default
        if not value:
            if not optional:
                raise ShowSlackError('Missing param. Requires -r (region) switch')
            else:
                return None

        value = value.lower()
        # check valid values.
        if value not in ['us-east-1', 'us-west-2']:
            raise ShowSlackError('Invalid value for -r (region) switch.'
                                 ' Was: {}'.format(value))

        # propagate the lower case value to aliases.
        self._cmd_inputs.set_cmd_inputs_value('r', value)
        self._cmd_inputs.set_cmd_inputs_value('region', value)

    def apply_service_rules(self, optional=False):
        """
        Apply rules for the (-s) service switch
        :return:
        """
        value = self._cmd_inputs.get_by_key('s')
        if not value:
            value = self._cmd_inputs.get_by_key('service')
        if not value:
            if not optional:
                raise ShowSlackError('Missing param. Requires -s (service) switch')
            else:
                return None

        # value = value.lower()

        # propagate the lower case value to aliases.
        self._cmd_inputs.set_cmd_inputs_value('s', value)
        self._cmd_inputs.set_cmd_inputs_value('service', value)

    def check_for_is_public_property(self):
        """
        This is a private method. It will check for a --show anywhere in the command.
        :return: None, it modifies internal state.
        """
        if self._cmd_inputs.contains_property('show'):
            self._cmd_inputs.set_slack_ui_is_public_response()

    def default_run_command(self):
        """
        This is the default run command available to all Cmd* classes.
        This will be the default implementation for the abstract base method
        run_command. It should be fine for most, if not all classes.

        Any classes that need to can implement thier own run_command and just
        comment this version out.

        :return:
        """
        # Get the inputs.
        cmd_inputs = self.get_cmd_input()
        if not cmd_inputs:
            raise ValueError('ERROR: no "cmd_inputs" found')

        print('run_command: cmd_inputs = {}'.format(cmd_inputs))

        # Get the sub-command.
        sub_cmd = cmd_inputs.get_sub_command()

        # Is this the sub_command help?
        if sub_cmd == 'help':
            return self.show_command_help()

        # What is sub-command run-type?
        cmd_props = self.get_cmd_properties()
        sub_cmd_props_key = 'props_{}'.format(sub_cmd)
        sub_cmd_props = cmd_props.get(sub_cmd_props_key)
        if not sub_cmd_props:
            err_msg = 'Failed for find props for sub_cmd={} key={}'.format(
                cmd_props, sub_cmd_props_key)
            print(err_msg)
            raise ShowSlackError('Failed to process command. Check logs.')
        run_type = sub_cmd_props.get('run-type')

        if not cmd_inputs.is_confirmation_cmd():
            cmd_specific_data = self.build_cmd_specific_data()
            cmd_inputs.set_cmd_specific_data(cmd_specific_data)

        # Read the sub-commands 'run-type' property to determine where it is run.
        if run_type == 'shorttask':
            # run the handler for this.

            # deal with short task confirmation commands.
            if cmd_inputs.is_confirmation_cmd():
                return self.invoke_confirm_command()

            method_name = 'invoke_{}'.format(sub_cmd)
            print('shorttask invokes method by function name: {}'.format(method_name))

            invoke_method = getattr(self, method_name)
            return invoke_method(cmd_inputs)

        elif run_type == 'longtask':
            where_am_i = cmd_inputs.get_where_am_i()
            if where_am_i == 'shorttask':
                custom_data = {
                    'key1': 'value1',
                    'key2': 'value2'
                }
                payload = self.create_longtask_payload(custom_data)
                slack_bud_env = cmd_inputs.get_slack_bud_env()
                bud_helper_util.invoke_longtask_lambda(slack_bud_env, payload)
                print('(debug). Invoking Longtask Lambda in {}'.format(slack_bud_env))
                return slack_ui_util.text_command_response('_Processing..._', '')
            elif where_am_i == 'longtask':

                # deal with confirmation commands
                if cmd_inputs.is_confirmation_cmd():
                    return self.invoke_confirm_command()

                # run the handler for this.
                method_name = 'invoke_{}'.format(sub_cmd)
                print('longtask invokes method by function name: {}'.format(method_name))

                invoke_method = getattr(self, method_name)
                return invoke_method(cmd_inputs)
            else:
                err_msg = 'Invalid setting, while trying to invoke_* in longtask.' \
                          ' where_am_i={}, cmd_inputs={}'.format(where_am_i, cmd_inputs)
                print(err_msg)
                raise ValueError(err_msg)

        elif run_type == 'docker':
            raise AttributeError('docker tasks not implemented')

    def store_original_message_text_in_session(self, original_message_text):
        """
        Stores the original message text in a session table and gives a
        session-id number for retriveing it later.

        This session id can be prepended to the callback_id, for confirmation
        and prompt type responses.

        :param original_message_text:
        :return: str - session-id to appened to callback_id
        """
        # Create a session id. (just use clock with milli-second accuracy.)
        session_id = int(round(time.time() * 1000))

        # expire the row in one hour.
        ttl = int(round(time.time()) + 3600)

        print('Storing original message: session_id={}, text={}'.format(
            session_id,
            original_message_text)
        )

        SLACK_SESSION_TABLE.put_item(
            Item={
                'slackBudSessionId': str(session_id),
                'text': original_message_text,
                'ttl': ttl
            }
        )
        return str(session_id)

    def get_original_message_text_from_callback_id(self, callback_id):
        """
        The callback_id has the following format.

            callback_<sub-cmd-name>_<anything>_<session-id>

        The session_id is at the very end. Get that and use it to
        look for the text of the original message.

        :param callback_id:
        :return:
        """
        # session_id should be the last part.
        parts = callback_id.split('_')
        num_parts = len(parts)
        session_id = parts[num_parts-1]

        original_message_text = self.get_original_message_text_from_session(session_id)

        print('getting original_message text session_id = {}, text={}'.format(
            session_id, original_message_text))  # temp

        if not original_message_text:
            raise ValueError('Failed to find original text for session_id = {}'.format(session_id))

        return original_message_text

    def get_original_message_text_from_session(self, session_id):
        """
        Get's the original message from a the SlackBudSession dynamoDB table.
        :param session_id:
        :return: str - original message
        """
        response = SLACK_SESSION_TABLE.get_item(
            Key={
                'slackBudSessionId': session_id
            }
        )

        if 'Item' not in response:
            return None
        return response['Item']['text']


def get_interface_version():
    """
    Will have multiple versions of SlackBud interface. This
    says which version.
    Version string looks like 1.0.0-string, like 1.0.0-sr
    :return:
    """
    return '1.0.0-sr'


# NOTE: Consider moving this to bud_helper_util to get import os out of this file.
def is_valid_token(params):
    """
    Verify the SlackToken which is included in environment of lambda function.

    :param params:
    :return: True if valid, otherwise False
    """
    token = params['token'][0]
    slack_env = get_slack_bud_environment(params)
    token_name = 'bud_' + slack_env + '_slack_token'
    ssm_token = get_ssm_parameter(token_name)
    print('new token name = {}'.format(token_name))
    if ssm_token == 'none':
        ssm_token = EXPECTED_TOKEN
    if token != ssm_token:
        # Log what you can about this request.
        user_id = params['user_id'][0]
        user = params['user_name'][0]
        print("ERROR: Invalid token from user: {}\nuser_id: {}\ntoken: {}\nexpected: {}"
              .format(user, user_id, token, EXPECTED_TOKEN))
        return False
    return True


# NOTE: Consider moving this to bud_helper_util to get import boto3 out of this file.
def look_up_bud_user(params):
    """
    Look-up userid in the BudUsers table.
    If found return the user name.
    :param params: params
    :return: return user name. If not found return None.
    """
    user_id = params['user_id'][0]
    response = BUD_USERS_TABLE.get_item(
        Key={
            'userid': user_id,
        }
    )

    if 'Item' not in response:
        # Log this user_id
        print("Invalid user_id: {}".format(user_id))
        return None
    return response['Item']
